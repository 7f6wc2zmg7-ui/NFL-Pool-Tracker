<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NFL Pool Tracker ‚≠ê </title>
<style>
  :root{
    --bg:#0b0f14; --card:#111820; --muted:#7a8796; --text:#f3f6fa; --accent:#5cc8ff;
    --border:#1c2632; --win:#1dd1a1; --loss:#ff6b6b; --pill:#1a2430;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:16px}
  h1{margin:0 0 8px;font-size:22px;letter-spacing:.3px}
  h2{margin:24px 0 8px;font-size:18px}
  .pill{display:inline-block;padding:2px 8px;border:1px solid var(--border);border-radius:999px;background:var(--pill);font-size:12px;margin-left:8px;color:var(--muted)}
  .meta{color:var(--muted);margin:0 0 12px;font-size:13px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:12px;margin:10px 0}
  .table-wrap{overflow:auto;border:1px solid var(--border);border-radius:8px}
  table{border-collapse:collapse;width:100%;min-width:620px}
  th,td{padding:10px;border-bottom:1px solid var(--border);text-align:left;font-size:13px}
  thead th{position:sticky;top:0;background:var(--card);z-index:1}
  th.small,td.small{font-size:12px;color:var(--muted)}
  .right{text-align:right}
  .subtle{color:var(--muted)}
  .subtotal{font-weight:600}
  .ok{color:var(--win)} .bad{color:var(--loss)}
  .owner{font-weight:600;letter-spacing:.2px}
  details{border:1px solid var(--border);border-radius:10px;margin:8px 0;background:var(--card)}
  summary{cursor:pointer;list-style:none;padding:12px 14px;font-weight:600}
  summary::-webkit-details-marker{display:none}
  .section-pad{padding:0 12px 12px}
  .grid-2{display:grid;gap:8px}
  @media (min-width:720px){ .grid-2{grid-template-columns:1fr 1fr} }
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;background:rgba(255,255,255,.06);padding:1px 6px;border-radius:6px;border:1px solid var(--border)}
  .badge{display:inline-block;padding:2px 6px;border:1px solid var(--border);border-radius:6px;font-size:12px;margin-left:6px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <h1>üèà NFL Pool Tracker ‚Äî v3 <span id="updated" class="pill">Loading‚Ä¶</span></h1>
  <p class="meta">Live data from <span class="kbd">data/predictions.json</span> (ESPN futures + H2H), preseason odds from <span class="kbd">data/odds.json</span>, rosters from <span class="kbd">data/rosters.json</span>, rules from <span class="kbd">data/rules.json</span>.</p>

  <!-- Leaderboard -->
  <div class="card">
    <h2>Leaderboard</h2>
    <div class="table-wrap">
      <table id="board">
        <thead>
          <tr><th>Owner</th><th class="right">Projected Points</th><th class="small">Breakdown</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Regular Season Section -->
  <div class="card">
    <h2>Regular Season</h2>
    <p class="meta">Shows <b>Current</b> (if available), <b>Projected Wins</b>, <b>O/U</b>, and <b>Implied Points</b> = Win-Total EV + Division Title EV.</p>
    <div id="regular-season" class="grid-2"></div>
  </div>

  <!-- Playoffs Section -->
  <div class="card">
    <h2>Playoff Detail</h2>
    <p class="meta">Shows % by round and EV by round. Subtotals include Wild Card Spot (10 pts if not division winner), WC Round, Divisional, Conference, SB Appearance, SB Win.</p>
    <div id="playoffs" class="grid-2"></div>
  </div>
</div>

<script>
/* ---------- utils ---------- */
function clamp01(x){ return Math.max(0, Math.min(1, Number(x)||0)); }
function pct(x){ const v = clamp01(x)*100; return isFinite(v) ? v.toFixed(1)+'%' : '‚Äî'; }
function mlToProb(ml){
  if (ml == null) return 0;
  const n = Number(String(ml).replace(/\s/g,''));
  if (!isFinite(n)) return 0;
  return n < 0 ? (-n)/((-n)+100) : 100/(n+100);
}
function devig(obj){
  const vals = Object.values(obj).map(v=>Number(v)||0).filter(v=>v>0);
  const s = vals.reduce((a,b)=>a+b,0);
  if(!s) return {};
  const out={}; for(const [k,v] of Object.entries(obj)){ const p=Number(v)||0; if(p>0) out[k]=p/s; }
  return out;
}
function mlToMultiplier(ml){ const n=Number(ml); if(!isFinite(n)) return 0; return n>=0 ? (n/100) : (100/Math.abs(n)); }
function winsProjFromNextGameProb(p){ return 17 * (Number(p||0)); }
function winTotalPoints(winsProj, ou, rules){
  const baseOver = Number(rules.win_total?.base_points_if_over ?? 20);
  const baseUnder = Number(rules.win_total?.base_points_if_not_over ?? -20);
  const deltaPts  = Number(rules.win_total?.points_per_win_delta ?? 1);
  const equalIsNotOver = !!rules.win_total?.equal_counts_as_not_over;
  if (!isFinite(ou)) return 0;
  if (winsProj > ou) return baseOver + (winsProj - ou) * deltaPts;
  if (winsProj < ou) return baseUnder - (ou - winsProj) * deltaPts;
  return equalIsNotOver ? baseUnder : 0;
}
async function safeJSON(path){
  try{ const r=await fetch(path,{cache:'no-store'}); if(!r.ok) return null; return await r.json(); }
  catch{ return null; }
}

/* ---------- main ---------- */
async function main(){
  const [pred, rules, rosters, odds] = await Promise.all([
    safeJSON('data/predictions.json'),
    safeJSON('data/rules.json'),
    safeJSON('data/rosters.json'),
    safeJSON('data/odds.json')
  ]);
  if (!pred || !rules || !rosters || !odds) {
    document.getElementById('updated').textContent = 'Error loading data';
    return;
  }
  document.getElementById('updated').textContent = 'Updated ' + new Date(pred.generatedAt).toLocaleString();

  /* maps */
  const byTeamNext = Object.create(null);
  for(const t of pred.nflNextGame||[]) byTeamNext[(t.team||'').toUpperCase()] = t;

  // futures (ESPN) + preseason div fallback
  const futures = Object.create(null); // TEAM -> {div, reach_sb, sb, make_playoffs}
  for (const [team, obj] of Object.entries(pred.nflFutures || {})) {
    const T = (team||'').toUpperCase();
    futures[T] = futures[T] || {};
    for (const [k,v] of Object.entries(obj||{})) futures[T][k] = Math.max(futures[T][k]||0, Number(v)||0);
  }
  const divGroups = {};
  for (const t of odds.teams||[]){
    const divKey = `${t.conference} ${t.division}`.toUpperCase();
    divGroups[divKey] = divGroups[divKey] || {};
    divGroups[divKey][(t.team||'').toUpperCase()] = mlToProb(t.div_ml);
  }
  for (const grp of Object.values(divGroups)){
    const norm = devig(grp);
    for (const [team, p] of Object.entries(norm)){
      futures[team] = futures[team] || {};
      if (futures[team].div == null) futures[team].div = p;
    }
  }

  const ouByTeam = Object.create(null);
  const divMlByTeam = Object.create(null);
  for(const t of odds.teams||[]){ const T=(t.team||'').toUpperCase(); ouByTeam[T]=t.ou_wins; divMlByTeam[T]=t.div_ml; }

  /* points config */
  const PTS_DIV_WIN_BASE = Number(rules.division_winner?.base_points ?? 20);
  const PTS_WC = Number(rules.wild_card_spot_points ?? 10);
  const PTS_WC_ROUND = Number(rules.playoff_points?.wc_round ?? 15);
  const PTS_DIV_ROUND = Number(rules.playoff_points?.divisional_round ?? 30);
  const PTS_CONF_CHAMP = Number(rules.playoff_points?.conference_champ ?? 50);
  const PTS_SB_APPEAR = Number(rules.playoff_points?.super_bowl_appearance ?? 75);
  const PTS_SB_WIN = Number(rules.playoff_points?.super_bowl_win ?? 100);

  /* compute per team, bucket by owner */
  const owners = {}; // owner -> { regRows:[], poRows:[], regSubtotal, poSubtotal, total }
  const leaderboard = [];

  for (const player of rosters.players||[]) {
    let totalOwner = 0;
    let regSubtotal = 0;
    let poSubtotal  = 0;

    const regRows = [];
    const poRows  = [];

    for (const pick of player.teams||[]) {
      const name = (pick.name||'').toUpperCase();

      // wins projection
      const nextProb = byTeamNext[name]?.impliedNextGameWinProb ?? 0.5;
      const projWins = winsProjFromNextGameProb(nextProb);

      // O/U and win-total points
      const ou = Number(ouByTeam[name] ?? NaN);
      const wtPts = winTotalPoints(projWins, ou, rules);

      // futures probabilities  (REPLACE everything down to just before // Totals)
// futures probabilities  (REPLACE from here down to just before // Totals)
const f = futures[name] || {};

// Division EV uses preseason ML multiplier √ó current P(div title)
const mult  = mlToMultiplier(divMlByTeam[name]);
const pDivTitle = clamp01(f.div ?? 0);              // P(win division)
const divEV = (PTS_DIV_WIN_BASE * mult) * pDivTitle;

// --- Playoff probability chain (midpoint interpolation + monotonic) ---

// Endpoints we (may) have
const pSB_win0  = clamp01(f.sb ?? 0);               // P(win SB)
let   pReachSB  = clamp01(f.reach_sb ?? 0);         // P(reach SB = win conference)
if (pReachSB < pSB_win0) pReachSB = pSB_win0;

// Top endpoint: P(make playoffs). If missing, conservative estimate from div + reachSB
let pPO = clamp01( f.make_playoffs ?? (pDivTitle + 2 * pReachSB) );
// Must be at least as big as reaching the SB:
if (pPO < pReachSB) pPO = pReachSB;

// WC round entry = WC teams that make playoffs (division winners skip WC round)
let pWCRound = clamp01(Math.max(pPO - pDivTitle, 0));

// Start Conf at least reachSB
let pConf = pReachSB;

// Divisional round sits between WC rd and Conf, never below P(div title)
let pDivRound = clamp01(Math.max(pDivTitle, (pWCRound + pConf) / 2));

// Apply midpoint rule to neighbors with bounds
// WC round midway between Playoffs and Divisional, bounded by them
pWCRound = clamp01(Math.max(pDivRound, Math.min(pPO, (pPO + pDivRound) / 2)));

// Conference midway between Divisional and ReachSB, bounded by them
pConf = clamp01(Math.min(pDivRound, Math.max(pReachSB, (pDivRound + pReachSB) / 2)));

// Enforce monotonic chain:
// P(playoffs) ‚â• P(WC rd) ‚â• P(Div rd) ‚â• P(Conf) ‚â• P(Reach SB) ‚â• P(SB win)
pWCRound  = Math.min(pPO, pWCRound);
pDivRound = Math.min(pWCRound, Math.max(pDivRound, pConf, pDivTitle));
pConf     = Math.min(pDivRound, Math.max(pConf, pReachSB));

const pSB_win = pSB_win0; // rename for clarity below

// EVs from these probabilities
const wcSpotEV  = PTS_WC        * Math.max(pPO - pDivTitle, 0);
const evWCRound = PTS_WC_ROUND  * pWCRound;
const evDivRound= PTS_DIV_ROUND * pDivRound;   // keep this name exactly
const evConf    = PTS_CONF_CHAMP* pConf;
const evSBApp   = PTS_SB_APPEAR * pReachSB;
const evSBWin   = PTS_SB_WIN    * pSB_win;
      // Totals
      const regPoints = wtPts + divEV; // regular-season subtotal component
      const poPoints  = wcSpotEV + evWCRound + evDivRound + evConf + evSBApp + evSBWin; // playoffs subtotal
      const teamTotal = regPoints + poPoints;

      regSubtotal += regPoints;
      poSubtotal  += poPoints;
      totalOwner  += teamTotal;

      // Tables
      const record = '‚Äî'; // placeholder until we wire standings (wins-losses)
      regRows.push({
        team: name,
        record,
        projWins: projWins,
        ou: isFinite(ou)?ou:'‚Äî',
        regPoints,
        wtPts, divEV
      });

      poRows.push({
        team: name,
        pWCspot, pReachWCRound, pReachDivRound, pReachConfRound, pReachSB, pSB,
        wcSpotEV, evWCRound, evDivRound, evConf, evSBApp, evSBWin,
        poPoints
      });
    }

    // sort per owner
    regRows.sort((a,b)=>b.regPoints - a.regPoints);
    poRows.sort((a,b)=>b.poPoints  - a.poPoints);

    owners[player.owner] = { regRows, poRows, regSubtotal, poSubtotal, total: totalOwner };
    leaderboard.push([player.owner, totalOwner, regSubtotal, poSubtotal]);
  }

  // Leaderboard render
  leaderboard.sort((a,b)=>b[1]-a[1]);
  const lb = document.querySelector('#board tbody'); lb.innerHTML='';
  for (const r of leaderboard){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class="owner">${r[0]}</td>
                    <td class="right">${r[1].toFixed(1)}</td>
                    <td class="small">Reg ${r[2].toFixed(1)} ‚Ä¢ PO ${r[3].toFixed(1)}</td>`;
    lb.appendChild(tr);
  }

  // Regular Season render (per-owner cards)
  const regHost = document.getElementById('regular-season');
  regHost.innerHTML = '';
  for (const [owner, data] of Object.entries(owners)){
    const box = document.createElement('details');
    box.open = false;
    box.innerHTML = `
      <summary>${owner}
        <span class="badge">Subtotal: ${data.regSubtotal.toFixed(1)}</span>
      </summary>
      <div class="section-pad">
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Team</th><th>Record</th><th class="right">Proj Wins</th><th class="right">O/U</th><th class="right">WT Pts</th><th class="right">Div EV</th><th class="right">Implied Pts</th></tr>
            </thead>
            <tbody></tbody>
            <tfoot>
              <tr><th colspan="6" class="right">Subtotal</th><th class="right subtotal">${data.regSubtotal.toFixed(1)}</th></tr>
            </tfoot>
          </table>
        </div>
      </div>`;
    const tbody = box.querySelector('tbody');
    for (const row of data.regRows){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${row.team}</td>
        <td class="subtle">${row.record}</td>
        <td class="right">${row.projWins.toFixed(1)}</td>
        <td class="right">${row.ou}</td>
        <td class="right">${row.wtPts.toFixed(1)}</td>
        <td class="right">${row.divEV.toFixed(1)}</td>
        <td class="right">${row.regPoints.toFixed(1)}</td>`;
      tbody.appendChild(tr);
    }
    regHost.appendChild(box);
  }

  // Playoffs render (per-owner cards)
  const poHost = document.getElementById('playoffs');
  poHost.innerHTML = '';
  for (const [owner, data] of Object.entries(owners)){
    const box = document.createElement('details');
    box.open = false;
    box.innerHTML = `
      <summary>${owner}
        <span class="badge">Subtotal: ${data.poSubtotal.toFixed(1)}</span>
      </summary>
      <div class="section-pad">
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>Team</th>
                <th class="right small">% WC Spot</th>
                <th class="right small">% WC Rnd</th>
                <th class="right small">% Div Rnd</th>
                <th class="right small">% Conf</th>
                <th class="right small">% SB App</th>
                <th class="right small">% SB Win</th>
                <th class="right">WC Spot EV</th>
                <th class="right">WC Rnd EV</th>
                <th class="right">Div Rnd EV</th>
                <th class="right">Conf EV</th>
                <th class="right">SB App EV</th>
                <th class="right">SB Win EV</th>
                <th class="right">PO Pts</th>
              </tr>
            </thead>
            <tbody></tbody>
            <tfoot>
              <tr><th colspan="13" class="right">Subtotal</th><th class="right subtotal">${data.poSubtotal.toFixed(1)}</th></tr>
            </tfoot>
          </table>
        </div>
      </div>`;
    const tbody = box.querySelector('tbody');
    for (const r of data.poRows){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.team}</td>
        <td class="right small">${pct(r.pWCspot)}</td>
        <td class="right small">${pct(r.pReachWCRound)}</td>
        <td class="right small">${pct(r.pReachDivRound)}</td>
        <td class="right small">${pct(r.pReachConfRound)}</td>
        <td class="right small">${pct(r.pReachSB)}</td>
        <td class="right small">${pct(r.pSB)}</td>
        <td class="right">${r.wcSpotEV.toFixed(1)}</td>
        <td class="right">${r.evWCRound.toFixed(1)}</td>
        <td class="right">${r.evDivRound.toFixed(1)}</td>
        <td class="right">${r.evConf.toFixed(1)}</td>
        <td class="right">${r.evSBApp.toFixed(1)}</td>
        <td class="right">${r.evSBWin.toFixed(1)}</td>
        <td class="right subtotal">${r.poPoints.toFixed(1)}</td>`;
      tbody.appendChild(tr);
    }
    poHost.appendChild(box);
  }
}

main().catch(e=>{
  document.getElementById('updated').textContent = 'Error';
  console.error(e);
});
</script>
</body>
</html>
