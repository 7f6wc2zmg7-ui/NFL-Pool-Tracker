<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NFL Pool Tracker</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;padding:20px;max-width:1000px}
  h1{margin:0 0 8px}
  .pill{display:inline-block;padding:2px 6px;border:1px solid #ddd;border-radius:999px;font-size:12px;margin-left:8px}
  .meta{color:#666;margin:0 0 16px}
  table{border-collapse:collapse;width:100%;margin-top:12px}
  th,td{border-bottom:1px solid #eee;padding:8px;text-align:left;vertical-align:top}
  .small{font-size:12px;color:#666}
</style>
</head>
<body>
<h1>NFL Pool <span id="updated" class="pill">…</span></h1>
<p class="meta">Data from <code>data/predictions.json</code> + <code>data/odds.json</code> + <code>data/rosters.json</code> + <code>data/rules.json</code>.</p>

<h2>Leaderboard (Projected)</h2>
<table id="board">
  <thead><tr><th>Owner</th><th>Projected Points</th><th class="small">Breakdown</th></tr></thead>
  <tbody></tbody>
</table>

<h2>Teams (Details)</h2>
<table id="teams">
  <thead><tr><th>Owner</th><th>Team</th><th>Proj Wins</th><th>O/U</th><th>WT Pts</th><th>Div EV</th><th>WC EV</th><th>WC Rnd</th><th>Div Rnd</th><th>Conf</th><th>SB App</th><th>SB Win</th></tr></thead>
  <tbody></tbody>
</table>

<script>
function clamp01(x){ return Math.max(0, Math.min(1, Number(x)||0)); }
function mlToProb(ml){
  if (ml == null) return 0;
  const s = String(ml).trim();
  const n = Number(s);
  if (!isFinite(n)) return 0;
  return n < 0 ? (-n)/((-n)+100) : 100/(n+100);
}
function devig(obj){
  const vals = Object.values(obj).map(v=>Number(v)||0).filter(v=>v>0);
  const s = vals.reduce((a,b)=>a+b,0);
  if(!s) return {};
  const out={}; for(const [k,v] of Object.entries(obj)){ const p=Number(v)||0; if(p>0) out[k]=p/s; }
  return out;
}
function mlToMultiplier(ml){ const n=Number(ml); if(!isFinite(n)) return 0; return n>=0 ? (n/100) : (100/Math.abs(n)); }
function winsProjFromNextGameProb(p){ return 17 * (Number(p||0)); }
function winTotalPoints(winsProj, ou, rules){
  const baseOver = Number(rules.win_total?.base_points_if_over ?? 20);
  const baseUnder = Number(rules.win_total?.base_points_if_not_over ?? -20);
  const deltaPts  = Number(rules.win_total?.points_per_win_delta ?? 1);
  const equalIsNotOver = !!rules.win_total?.equal_counts_as_not_over;
  if (!isFinite(ou)) return 0;
  if (winsProj > ou) return baseOver + (winsProj - ou) * deltaPts;
  if (winsProj < ou) return baseUnder - (ou - winsProj) * deltaPts;
  return equalIsNotOver ? baseUnder : 0;
}

async function safeJSON(path){
  try{ const r=await fetch(path,{cache:'no-store'}); if(!r.ok) return null; return await r.json(); }
  catch{ return null; }
}

async function main(){
  const [pred, rules, rosters, odds] = await Promise.all([
    safeJSON('data/predictions.json'),
    safeJSON('data/rules.json'),
    safeJSON('data/rosters.json'),
    safeJSON('data/odds.json')
  ]);
  if (!pred || !rules || !rosters || !odds) {
    document.getElementById('updated').textContent = 'Error loading data';
    return;
  }
  document.getElementById('updated').textContent = 'Updated ' + new Date(pred.generatedAt).toLocaleString();

  // Build map of next-game probs
  const byTeamNext = Object.create(null);
  for(const t of pred.nflNextGame||[]) byTeamNext[(t.team||'').toUpperCase()] = t;

  // Build futures object:
  // 1) Use ESPN futures if present
  const futures = Object.create(null); // TEAM -> {div, reach_sb, sb, make_playoffs}
  for (const [team, obj] of Object.entries(pred.nflFutures || {})) {
    const T = (team||'').toUpperCase();
    futures[T] = futures[T] || {};
    for (const [k,v] of Object.entries(obj||{})) futures[T][k] = Math.max(futures[T][k]||0, Number(v)||0);
  }
  // 2) Fallback: derive P(div) from preseason division ML in odds.json (de-vig per division)
  const divGroups = {};
  for (const t of odds.teams||[]){
    const divKey = `${t.conference} ${t.division}`.toUpperCase();
    divGroups[divKey] = divGroups[divKey] || {};
    divGroups[divKey][(t.team||'').toUpperCase()] = mlToProb(t.div_ml);
  }
  for (const grp of Object.values(divGroups)){
    const norm = devig(grp);
    for (const [team, p] of Object.entries(norm)){
      futures[team] = futures[team] || {};
      if (futures[team].div == null) futures[team].div = p;
    }
  }

  // Lookup O/U + division ML
  const ouByTeam = Object.create(null);
  const divMlByTeam = Object.create(null);
  for(const t of odds.teams||[]){ const T=(t.team||'').toUpperCase(); ouByTeam[T]=t.ou_wins; divMlByTeam[T]=t.div_ml; }

  // Points config
  const PTS_DIV_WIN_BASE = Number(rules.division_winner?.base_points ?? 20);
  const PTS_WC = Number(rules.wild_card_spot_points ?? 10);
  const PTS_WC_ROUND = Number(rules.playoff_points?.wc_round ?? 15);
  const PTS_DIV_ROUND = Number(rules.playoff_points?.divisional_round ?? 30);
  const PTS_CONF_CHAMP = Number(rules.playoff_points?.conference_champ ?? 50);
  const PTS_SB_APPEAR = Number(rules.playoff_points?.super_bowl_appearance ?? 75);
  const PTS_SB_WIN = Number(rules.playoff_points?.super_bowl_win ?? 100);

  const leaderboard = [];
  const teamRows = [];

  for (const player of rosters.players||[]) {
    let total = 0;
    const parts = [];

    for (const pick of player.teams||[]) {
      const name = (pick.name||'').toUpperCase();

      // Proj wins from next-game prob (placeholder)
      const nextProb = byTeamNext[name]?.impliedNextGameWinProb ?? 0.5;
      const projWins = winsProjFromNextGameProb(nextProb);

      // Win-total EV vs preseason OU
      const ou = Number(ouByTeam[name] ?? NaN);
      const wtPts = winTotalPoints(projWins, ou, rules);

      // Futures-based probabilities (ESPN if available, else fallback div only)
      const f = futures[name] || {};
      const pDiv = clamp01(f.div ?? 0);
      const pReachSB = clamp01(f.reach_sb ?? 0);
      const pSB = clamp01(f.sb ?? 0);

      // Conservative P(make playoffs) if missing
      const pPO = clamp01( (f.make_playoffs ?? (pDiv + 2 * pReachSB)) );
      const pWCspot = Math.max(pPO - pDiv, 0);

      // EV: Division winner points are multiplied by preseason ML multiplier × P(div now)
      const mult = mlToMultiplier(divMlByTeam[name]);
      const divEV = (PTS_DIV_WIN_BASE * mult) * pDiv;

      // Round reach (conservative)
      const assumedWCAdvance = 0.40;
      const pReachWCRound = clamp01(pWCspot);
      const pReachDivRound = clamp01(Math.max(pDiv, pDiv + pWCspot * assumedWCAdvance));
      const pReachConfRound = clamp01(Math.max(f.reach_conf_champ ?? 0, Math.max(pDiv, Math.min(1, pReachSB * 2))));

      const wcSpotEV = PTS_WC * pWCspot;
      const evWCRound  = PTS_WC_ROUND   * pReachWCRound;
      const evDivRound = PTS_DIV_ROUND  * pReachDivRound;
      const evConf     = PTS_CONF_CHAMP * pReachConfRound;
      const evSBApp    = PTS_SB_APPEAR  * pReachSB;
      const evSBWin    = PTS_SB_WIN     * pSB;

      const teamTotal = wtPts + divEV + wcSpotEV + evWCRound + evDivRound + evConf + evSBApp + evSBWin;
      total += teamTotal;

      parts.push(`${name} ${teamTotal.toFixed(1)} (WT ${wtPts.toFixed(1)} | DivEV ${divEV.toFixed(1)} | PO EV ${(wcSpotEV+evWCRound+evDivRound+evConf+evSBApp+evSBWin).toFixed(1)})`);
      teamRows.push([
        player.owner, name,
        projWins.toFixed(1),
        isFinite(ou)?ou:'—',
        wtPts.toFixed(1),
        divEV.toFixed(1),
        wcSpotEV.toFixed(1),
        evWCRound.toFixed(1),
        evDivRound.toFixed(1),
        evConf.toFixed(1),
        evSBApp.toFixed(1),
        evSBWin.toFixed(1)
      ]);
    }

    leaderboard.push([player.owner, total, parts.join(' • ')]);
  }

  leaderboard.sort((a,b)=>b[1]-a[1]);

  // Render Leaderboard
  const lb = document.querySelector('#board tbody'); lb.innerHTML='';
  for(const r of leaderboard){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${r[0]}</td><td>${r[1].toFixed(1)}</td><td class="small">${r[2]}</td>`;
    lb.appendChild(tr);
  }

  // Render Teams table
  const tt = document.querySelector('#teams tbody'); tt.innerHTML='';
  for(const r of teamRows){
    const tr = document.createElement('tr');
    tr.innerHTML = r.map(x=>`<td>${x}</td>`).join('');
    tt.appendChild(tr);
  }
}

main().catch(e=>{
  document.getElementById('updated').textContent = 'Error loading data';
  console.error(e);
});
</script>
</body>
</html>
