<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NFL Pool Tracker ⭐</title>
<<style>
  /* ===== NFL Pool Tracker — Snazzy ND-inspired theme + mobile-first tables ===== */
  :root{
    --nd-navy:#0C2340; --nd-gold:#C99700;
    --bg:#0b0f14; --card:#111820; --muted:#8ea0b4; --text:#f3f6fa;
    --accent:#5cc8ff; --border:#1c2632; --pill:#0f1a28;
    --win:#19d3a3; --loss:#ff6b6b;
    --shadow: 0 8px 18px rgba(0,0,0,.25), 0 1px 0 rgba(255,255,255,.02) inset;
  }

  *{ box-sizing:border-box }
  html,body{
    margin:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }

  /* Header band (works even if you don't have a hero div) */
  .hero, .topband{
    background:linear-gradient(135deg,var(--nd-navy),#0b1830 62%);
    border-bottom:1px solid #0f1c2e;
    box-shadow:0 6px 20px rgba(0,0,0,.25);
  }
  .hero .wrap, .topband .wrap{
    max-width:1100px; margin:0 auto; padding:14px 16px; display:flex; gap:12px; align-items:center;
  }

  /* Layout */
  .wrap-main,.wrap{ max-width:1100px; margin:0 auto; padding:16px }
  h1{ margin:0 0 8px; font-size:22px; letter-spacing:.2px }
  h2{ margin:18px 0 8px; font-size:18px }

  /* Chips, badges, keycaps */
  .pill{
    display:inline-block; padding:3px 9px; border:1px solid var(--border); border-radius:999px;
    background:var(--pill); color:var(--muted); font-size:12px;
  }
  .badge{
    display:inline-block; padding:2px 6px; border:1px solid var(--border); border-radius:6px;
    color:var(--muted); font-size:12px; margin-left:6px;
  }
  .kbd{
    font:12px/1.2 ui-monospace,Menlo,Consolas,monospace;
    background:rgba(255,255,255,.06); padding:1px 6px; border-radius:6px; border:1px solid var(--border)
  }
  .meta{ color:var(--muted); margin:0 0 10px; font-size:13px }

  /* Cards */
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
    border:1px solid var(--border); border-radius:12px; padding:12px; margin:10px 0;
    box-shadow:var(--shadow);
  }

  /* Tables: tighter + mobile-first */
  .table-wrap{ overflow:auto; border:1px solid var(--border); border-radius:10px; }
  .table-wrap::-webkit-scrollbar{ height:8px }
  .table-wrap::-webkit-scrollbar-thumb{ background:#203044; border-radius:8px }

  table{ border-collapse:collapse; width:100%; min-width:560px }
  th,td{
    padding:8px 10px; border-bottom:1px solid var(--border);
    text-align:left; font-size:13px; white-space:nowrap;
  }
  thead th{ position:sticky; top:0; background:var(--card); z-index:1; }
  .sticky-first thead th:first-child,
  .sticky-first tbody td:first-child{
    position:sticky; left:0; z-index:2; background:var(--card);
  }
  .zebra tbody tr:nth-child(odd){ background:rgba(255,255,255,.02) }

  /* Right-align numeric cells, small helper */
  .right{ text-align:right }
  .small{ font-size:12px; color:var(--muted) }
  .subtotal{ font-weight:600 }
  .owner{ font-weight:700; letter-spacing:.2px }

  /* Rank badge (for leaderboard #1, #2, …) */
  .rank{
    width:42px; text-align:center; font-weight:800; color:var(--nd-gold);
    text-shadow:0 0 10px rgba(201,151,0,.15);
  }

  /* Hide non-essential columns on phones; keep scores visible without scrolling */
  .hide-sm{ display:none }
  @media (min-width:721px){ .hide-sm{ display:table-cell } }

  /* Phone-specific tightening */
  @media (max-width:720px){
    th,td{ padding:6px 8px; font-size:12px }
    table{ min-width:520px }
    .meta{ font-size:12px }
    .rank{ width:36px }
    /* Optional: slightly reduce card padding */
    .card{ padding:10px }
  }

  /* Accents for good/bad */
  .ok{ color:var(--win) } .bad{ color:var(--loss) }

  /* Subtle ND accent border on headings */
  h2{ border-left:4px solid rgba(201,151,0,.35); padding-left:8px }
</style>
</head>
<body>
<div class="hero">
  <div class="wrap">
    <div class="brand">
      <span class="logo"><span class="nd">ND</span><span class="nfl"></span></span>
      NFL Pool Tracker
    </div>
    <div id="updated" class="pill">Loading…</div>
  </div>
</div>

<div class="wrap-main">
  <p class="meta">Data: <span class="kbd">data/predictions.json</span> • <span class="kbd">data/odds.json</span> • <span class="kbd">data/rosters.json</span> • <span class="kbd">data/rules.json</span></p>

  <!-- Leaderboard -->
  <div class="card">
    <h2>Leaderboard</h2>
    <div class="table-wrap sticky-first zebra">
      <table id="board">
        <thead>
          <tr>
            <th class="rank">#</th>
            <th>Owner</th>
            <th class="right">Projected Points</th>
            <th class="small">Breakdown</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Regular Season -->
  <div class="card">
    <h2>Regular Season <span class="badge">O/U: Covers → Manual → Preseason</span></h2>
    <p class="meta">Columns: <b>Current O/U</b>, <b>Pre O/U</b>, <b>WT Points</b>, <b>Div Pre (ML & %)</b>, <b>Div Now (%)</b>, <b>Div EV</b>, <b>Total</b>.</p>
    <div id="regular-season" class="grid-2"></div>
  </div>

  <!-- Playoffs -->
  <div class="card">
    <h2>Playoff Detail</h2>
    <p class="meta">% by round + EV by round; league totals normalized to NFL bracket (14/12/8/4/2/1).</p>
    <div id="playoffs" class="grid-2"></div>
  </div>

  <!-- League totals -->
  <div id="leagueTotals" class="card" style="">
    <h2>League totals (after normalization)</h2>
    <p class="meta"><span class="kbd">Targets</span>: WC Spot=14 • WC Rnd=12 • Div Rnd=8 • Conf=4 • SB App=2 • SB Win=1</p>
    <div class="table-wrap">
      <table>
        <thead><tr><th>Round</th><th class="right">Sum</th><th class="right small">Target</th></tr></thead>
        <tbody id="leagueTotalsBody"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
/* ---------- utils ---------- */
function clamp01(x){ return Math.max(0, Math.min(1, Number(x)||0)); }
function pct(x){ const v = clamp01(x)*100; return isFinite(v) ? v.toFixed(1)+'%' : '—'; }
function mlToProb(ml){
  if (ml == null) return 0;
  const n = Number(String(ml).replace(/[()\\s]/g,''));
  if (!isFinite(n)) return 0;
  return n < 0 ? (-n)/((-n)+100) : 100/(n+100);
}
function mlToMultiplier(ml){
  const n = Number(String(ml).replace(/[()\\s]/g,''));
  if (!isFinite(n)) return 0;
  return n>=0 ? (n/100) : (100/Math.abs(n));
}
function devig(obj){
  const vals = Object.values(obj).map(v=>Number(v)||0).filter(v=>v>0);
  const s = vals.reduce((a,b)=>a+b,0);
  if(!s) return {};
  const out={}; for (const [k,v] of Object.entries(obj)){ const p=Number(v)||0; if(p>0) out[k]=p/s; }
  return out;
}
function winTotalPoints(winsProj, ou, rules){
  const baseOver = Number(rules.win_total?.base_points_if_over ?? 20);
  const baseUnder = Number(rules.win_total?.base_points_if_not_over ?? -20);
  const deltaPts  = Number(rules.win_total?.points_per_win_delta ?? 1);
  // IMPORTANT: a tie is 0 now (ignores rules.equal_counts_as_not_over)
  if (!isFinite(ou)) return 0;
  if (winsProj > ou) return baseOver + (winsProj - ou) * deltaPts;
  if (winsProj < ou) return baseUnder - (ou - winsProj) * deltaPts;
  return 0; // tie
}
async function safeJSON(path){
  try{ const r=await fetch(path,{cache:'no-store'}); if(!r.ok) return null; return await r.json(); }
  catch{ return null; }
}

/* ---------- main ---------- */
async function main(){
  const [pred, rules, rosters, odds] = await Promise.all([
    safeJSON('data/predictions.json'),
    safeJSON('data/rules.json'),
    safeJSON('data/rosters.json'),
    safeJSON('data/odds.json')
  ]);
  if (!pred || !rules || !rosters || !odds) {
    const u = document.getElementById('updated'); if(u) u.textContent='Error loading data'; return;
  }
  const u = document.getElementById('updated');
  if(u) u.textContent = 'Updated ' + new Date(pred.generatedAt).toLocaleString();

  /* preseason division prob (devig by division) */
  const byDivGroup = {};
  for (const t of odds.teams||[]){
    const g = (t.conference + ' ' + t.division).toUpperCase();
    byDivGroup[g] = byDivGroup[g] || {};
    byDivGroup[g][(t.team||'').toUpperCase()] = mlToProb(t.div_ml);
  }
  const preDivProb = {};
  for (const g of Object.values(byDivGroup)){
    const d = devig(g);
    for (const [team,p] of Object.entries(d)) preDivProb[team] = p;
  }

  /* current futures (ESPN) */
  const futures = Object.create(null);
  for (const [team, obj] of Object.entries(pred.nflFutures || {})) {
    const T = (team||'').toUpperCase(); futures[T] = futures[T] || {};
    for (const [k,v] of Object.entries(obj||{})) futures[T][k] = Math.max(futures[T][k]||0, Number(v)||0);
  }

  /* preseason O/U + ML (for display) */
  const preOUByTeam = Object.create(null);
  const preDivMLByTeam = Object.create(null);
  for (const t of odds.teams||[]){
    const T = (t.team||'').toUpperCase();
    preOUByTeam[T] = Number(t.ou_wins);
    preDivMLByTeam[T] = t.div_ml;
  }

  /* current O/U (Covers -> manual -> preseason) */
  const curOUByTeam = Object.create(null);
  if (pred.nflCurrentOU && typeof pred.nflCurrentOU === 'object') {
    for (const [team, val] of Object.entries(pred.nflCurrentOU)) {
      const T = team.toUpperCase(); const n = Number(val);
      if (Number.isFinite(n)) curOUByTeam[T] = n;
    }
  }
  const manualOU = await safeJSON('data/current_ou.manual.json');
  if (manualOU && typeof manualOU === 'object') {
    for (const [team, val] of Object.entries(manualOU)) {
      const T = team.toUpperCase(); if (!(T in curOUByTeam)) {
        const n = Number(val); if (Number.isFinite(n)) curOUByTeam[T] = n;
      }
    }
  }
  for (const [T, n] of Object.entries(preOUByTeam)) if (!(T in curOUByTeam)) curOUByTeam[T] = n;

  /* points config */
  const P_DIV = Number(rules.division_winner?.base_points ?? 20);
  const P_WC_SPOT = Number(rules.wild_card_spot_points ?? 10);
  const P_WC = Number(rules.playoff_points?.wc_round ?? 15);
  const P_DIV_R = Number(rules.playoff_points?.divisional_round ?? 30);
  const P_CONF = Number(rules.playoff_points?.conference_champ ?? 50);
  const P_SBA = Number(rules.playoff_points?.super_bowl_appearance ?? 75);
  const P_SB = Number(rules.playoff_points?.super_bowl_win ?? 100);

  /* first pass: compute raw chains, store rows (no EV yet) */
  const owners = {}; const leaderboard = [];
  const allPORows = []; // keep references for normalization pass

  for (const player of rosters.players||[]) {
    const regRows = [], poRows = [];
    let regSubtotal = 0, poSubtotal = 0, totalOwner = 0;

    for (const pick of player.teams||[]) {
      const name = (pick.name||'').toUpperCase();

      const preOU = preOUByTeam[name];
      const curOU = Number.isFinite(curOUByTeam[name]) ? curOUByTeam[name] : preOU;
      const projWins = curOU;
      const wtPts = winTotalPoints(projWins, preOU, rules);

      const preDivML = preDivMLByTeam[name];
      const preDivPct = preDivProb[name] ?? (isFinite(mlToProb(preDivML)) ? mlToProb(preDivML) : 0);
      const curDivPct = clamp01((futures[name]?.div) ?? preDivPct);

      /* regular-season subtotal (no normalization needed) */
      const mult = mlToMultiplier(preDivML);
      const divEV = P_DIV * mult * curDivPct;
      const regPts = wtPts + divEV;

      regRows.push({
        team:name, curOU, preOU, wtPts,
        preDivML, preDivPct, curDivPct, divEV,
        regPts
      });
      regSubtotal += regPts;

      /* raw playoff chain (to be normalized league-wide) */
      const f = futures[name] || {};
      let pSB  = clamp01(f.sb ?? 0);
      let pSBA = clamp01(f.reach_sb ?? 0);
      const pDiv = curDivPct;
      let pPO   = clamp01(f.make_playoffs ?? (pDiv + 2*pSBA));
      if (pPO < pSBA) pPO = pSBA;
      const pWCspot = clamp01(Math.max(pPO - pDiv, 0));
      // structure-aware smoothing (fixed params now)
      const BYE = 0.25, ADV = 0.475; // (kept near your prior “felt right” setting)
      let pWCR  = clamp01(pWCspot + (1 - BYE) * pDiv);
      let pDivR = clamp01(ADV * pWCR + BYE * pDiv);
      let pConf = clamp01(ADV * pDivR);
      if (!f.reach_sb) pSBA = clamp01(Math.max(pSBA, ADV * pConf));
      // monotone
      pSBA = Math.max(pSBA, pSB);
      pConf = Math.max(pConf, pSBA);
      pDivR = Math.max(pDivR, pConf);
      pWCR  = Math.max(pWCR, pDivR);
      pWCR  = Math.min(pWCR, pPO);

      const poRow = { owner:player.owner, team:name, pPO, pDiv, pWCspot, pWCR, pDivR, pConf, pSBA, pSB,
                      // placeholders for EVs/poPts to be filled after normalization:
                      wcSpotEV:0, evWCR:0, evDivR:0, evConf:0, evSBA:0, evSB:0, poPts:0 };
      poRows.push(poRow);
      allPORows.push(poRow);

      // will add poPts & totals after normalization pass
    }

    owners[player.owner] = { regRows, poRows, regSubtotal, poSubtotal:0, total:0 };
    leaderboard.push([player.owner, 0, regSubtotal, 0]); // fill after normalization
  }

  /* second pass: normalize league totals to exact targets, then compute EVs */
  const targets = { wcSpot:14, wcr:12, divr:8, conf:4, sba:2, sb:1 };

  function sumField(rows, f){ return rows.reduce((a,r)=>a+(r[f]||0),0); }
  let S_wcSpot = sumField(allPORows,'pWCspot');
  let S_wcr    = sumField(allPORows,'pWCR');
  let S_divr   = sumField(allPORows,'pDivR');
  let S_conf   = sumField(allPORows,'pConf');
  let S_sba    = sumField(allPORows,'pSBA');
  let S_sb     = sumField(allPORows,'pSB');

  const eps = 1e-9;
  const F_wcSpot = targets.wcSpot / Math.max(S_wcSpot, eps);
  const F_wcr    = targets.wcr    / Math.max(S_wcr, eps);
  const F_divr   = targets.divr   / Math.max(S_divr, eps);
  const F_conf   = targets.conf   / Math.max(S_conf, eps);
  const F_sba    = targets.sba    / Math.max(S_sba, eps);
  const F_sb     = targets.sb     / Math.max(S_sb, eps);

  for (const r of allPORows){
    // scale each round
    let pSB   = clamp01(r.pSB   * F_sb);
    let pSBA  = clamp01(r.pSBA  * F_sba);
    let pConf = clamp01(r.pConf * F_conf);
    let pDivR = clamp01(r.pDivR * F_divr);
    let pWCR  = clamp01(r.pWCR  * F_wcr);
    let pWCspot = clamp01(r.pWCspot * F_wcSpot);
    // re-impose chain + bracket caps
    pSBA  = Math.max(pSBA, pSB);
    pConf = Math.max(pConf, pSBA);
    pDivR = Math.max(pDivR, pConf);
    pWCR  = Math.max(pWCR, pDivR);
    pWCR  = Math.min(pWCR, r.pPO);       // can't exceed make-playoffs
    // (WC Spot is separate from WCR; keep its scaled value)
    r.pSB = pSB; r.pSBA = pSBA; r.pConf = pConf; r.pDivR = pDivR; r.pWCR = pWCR; r.pWCspot = pWCspot;

    // EVs after normalization
    r.wcSpotEV = P_WC_SPOT * r.pWCspot;
    r.evWCR  = P_WC * r.pWCR;
    r.evDivR = P_DIV_R * r.pDivR;
    r.evConf = P_CONF * r.pConf;
    r.evSBA  = P_SBA * r.pSBA;
    r.evSB   = P_SB * r.pSB;
    r.poPts  = r.wcSpotEV + r.evWCR + r.evDivR + r.evConf + r.evSBA + r.evSB;
  }

  /* recompute owner subtotals/totals and render */
  const board = [];
  for (const [owner,data] of Object.entries(owners)){
    // sum po from normalized rows
    data.poSubtotal = data.poRows.reduce((a,r)=>a + r.poPts, 0);
    data.total = data.regSubtotal + data.poSubtotal;
    board.push([owner, data.total, data.regSubtotal, data.poSubtotal]);
  }

  // Leaderboard
  board.sort((a,b)=>b[1]-a[1]);
  const lb = document.querySelector('#board tbody'); lb.innerHTML='';
  board.forEach((r,i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class="rank">${i+1}</td>
                    <td class="owner">${r[0]}</td>
                    <td class="right">${r[1].toFixed(1)}</td>
                    <td class="small">Reg ${r[2].toFixed(1)} • PO ${r[3].toFixed(1)}</td>`;
    lb.appendChild(tr);
  });

  // Regular Season (unchanged structure; already built)
  const regHost = document.getElementById('regular-season'); regHost.innerHTML='';
  for (const [owner, data] of Object.entries(owners)){
    const box = document.createElement('details');
    box.open = false;
    box.innerHTML = `
      <summary>${owner}
        <span class="badge">Subtotal: ${data.regSubtotal.toFixed(1)}</span>
      </summary>
      <div class="section-pad">
        <div class="table-wrap sticky-first zebra">
          <table>
           <thead>
  <tr>
    <th>Team</th>
    <th class="right">Total</th>
    <th class="right">Current O/U</th>
    <th class="right">WT Points</th>
    <th class="right small">Div Now (%)</th>
    <th class="right hide-sm">Pre O/U</th>
    <th class="right small hide-sm">Div Pre (ML)</th>
    <th class="right small hide-sm">Div Pre (%)</th>
    <th class="right hide-sm">Div EV</th>
  </tr>
</thead>
            <tbody></tbody>
            <tfoot>
              <tr><th colspan="8" class="right">Subtotal</th><th class="right subtotal">${data.regSubtotal.toFixed(1)}</th></tr>
            </tfoot>
          </table>
        </div>
      </div>`;
    const tbody = box.querySelector('tbody');
    for (const r of data.regRows){
      const tr = document.createElement('tr');
      tr.innerHTML = `
  <td>${r.team}</td>
  <td class="right">${r.regPts.toFixed(1)}</td>
  <td class="right">${isFinite(r.curOU)?r.curOU.toFixed(1):'—'}</td>
  <td class="right">${r.wtPts.toFixed(1)}</td>
  <td class="right small">${pct(r.curDivPct ?? 0)}</td>
  <td class="right hide-sm">${isFinite(r.preOU)?r.preOU.toFixed(1):'—'}</td>
  <td class="right small hide-sm">${r.preDivML ?? '—'}</td>
  <td class="right small hide-sm">${pct(r.preDivPct ?? 0)}</td>
  <td class="right hide-sm">${r.divEV.toFixed(1)}</td>`;
      tbody.appendChild(tr);
    }
    regHost.appendChild(box);
  }

  // Playoffs
  const poHost = document.getElementById('playoffs'); poHost.innerHTML='';
  for (const [owner, data] of Object.entries(owners)){
    const box = document.createElement('details');
    box.open = false;
    box.innerHTML = `
      <summary>${owner}
        <span class="badge">Subtotal: ${data.poSubtotal.toFixed(1)}</span>
      </summary>
      <div class="section-pad">
        <div class="table-wrap sticky-first zebra">
          <table>
            <thead>
              <tr>
                <th>Team</th>
                <th class="right small">% WC Spot</th>
                <th class="right small">% WC Rnd</th>
                <th class="right small">% Div Rnd</th>
                <th class="right small">% Conf</th>
                <th class="right small">% SB App</th>
                <th class="right small">% SB Win</th>
                <th class="right">PO Pts</th>
              </tr>
            </thead>
            <tbody></tbody>
            <tfoot>
              <tr><th colspan="7" class="right">Subtotal</th><th class="right subtotal">${data.poSubtotal.toFixed(1)}</th></tr>
            </tfoot>
          </table>
        </div>
      </div>`;
    const tbody = box.querySelector('tbody');
    for (const r of data.poRows){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.team}</td>
        <td class="right small">${pct(r.pWCspot)}</td>
        <td class="right small">${pct(r.pWCR)}</td>
        <td class="right small">${pct(r.pDivR)}</td>
        <td class="right small">${pct(r.pConf)}</td>
        <td class="right small">${pct(r.pSBA)}</td>
        <td class="right small">${pct(r.pSB)}</td>
        <td class="right">${r.poPts.toFixed(1)}</td>`;
      tbody.appendChild(tr);
    }
    poHost.appendChild(box);
  }

  // League totals (now exact on targets after normalization)
  function sum(rows,f){return rows.reduce((a,r)=>a+(r[f]||0),0)}
  const totals = {
    wcSpot: sum(allPORows,'pWCspot'),
    wcr:    sum(allPORows,'pWCR'),
    divr:   sum(allPORows,'pDivR'),
    conf:   sum(allPORows,'pConf'),
    sba:    sum(allPORows,'pSBA'),
    sb:     sum(allPORows,'pSB')
  };
  const tgt = targets;
  const body = document.getElementById('leagueTotalsBody');
  body.innerHTML = [
    ['WC Spot', totals.wcSpot, tgt.wcSpot],
    ['WC Round', totals.wcr, tgt.wcr],
    ['Div Round', totals.divr, tgt.divr],
    ['Conf', totals.conf, tgt.conf],
    ['SB App', totals.sba, tgt.sba],
    ['SB Win', totals.sb, tgt.sb]
  ].map(([label,val,goal]) =>
    `<tr><td>${label}</td><td class="right">${val.toFixed(2)}</td><td class="right small">${goal}</td></tr>`
  ).join('');
}
main().catch(e=>{ const u=document.getElementById('updated'); if(u) u.textContent='Error'; console.error(e); });
</script>
</body>
</html>
