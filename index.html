<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NFL Pool Tracker ‚≠ê </title>
<style>
  :root{
    --bg:#0b0f14; --card:#111820; --muted:#7a8796; --text:#f3f6fa; --accent:#5cc8ff;
    --border:#1c2632; --win:#1dd1a1; --loss:#ff6b6b; --pill:#1a2430;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:16px}
  h1{margin:0 0 8px;font-size:22px;letter-spacing:.3px}
  h2{margin:24px 0 8px;font-size:18px}
  .pill{display:inline-block;padding:2px 8px;border:1px solid var(--border);border-radius:999px;background:var(--pill);font-size:12px;margin-left:8px;color:var(--muted)}
  .meta{color:var(--muted);margin:0 0 12px;font-size:13px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:12px;margin:10px 0}
  .table-wrap{overflow:auto;border:1px solid var(--border);border-radius:8px}
  table{border-collapse:collapse;width:100%;min-width:620px}
  th,td{padding:10px;border-bottom:1px solid var(--border);text-align:left;font-size:13px}
  thead th{position:sticky;top:0;background:var(--card);z-index:1}
  th.small,td.small{font-size:12px;color:var(--muted)}
  .right{text-align:right}
  .subtle{color:var(--muted)}
  .subtotal{font-weight:600}
  .ok{color:var(--win)} .bad{color:var(--loss)}
  .owner{font-weight:600;letter-spacing:.2px}
  details{border:1px solid var(--border);border-radius:10px;margin:8px 0;background:var(--card)}
  summary{cursor:pointer;list-style:none;padding:12px 14px;font-weight:600}
  summary::-webkit-details-marker{display:none}
  .section-pad{padding:0 12px 12px}
  .grid-2{display:grid;gap:8px}
  @media (min-width:720px){ .grid-2{grid-template-columns:1fr 1fr} }
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;background:rgba(255,255,255,.06);padding:1px 6px;border-radius:6px;border:1px solid var(--border)}
  .badge{display:inline-block;padding:2px 6px;border:1px solid var(--border);border-radius:6px;font-size:12px;margin-left:6px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <h1>üèà NFL Pool Tracker ‚Äî v3 <span id="updated" class="pill">Loading‚Ä¶</span></h1>
  <p class="meta">Live data from <span class="kbd">data/predictions.json</span> (ESPN futures + H2H), preseason odds from <span class="kbd">data/odds.json</span>, rosters from <span class="kbd">data/rosters.json</span>, rules from <span class="kbd">data/rules.json</span>.</p>
<div class="card" style="margin-bottom:12px">
  <label for="tauRange">Playoff Smoothing (TAU): </label>
  <input type="range" id="tauRange" min="0.3" max="0.8" step="0.05" value="0.65"
         style="width:200px;vertical-align:middle">
  <span id="tauVal">0.65</span>
</div>

<div id="leagueTotals" class="card" style="display:none">
  <h2>League totals</h2>
  <p class="meta">Sums of probabilities across all teams (expected counts). TAU: <span id="tauShow">‚Äî</span></p>
  <div class="table-wrap"><table><tbody id="leagueTotalsBody"></tbody></table></div>
</div>
  <!-- Leaderboard -->
  <div class="card">
    <h2>Leaderboard</h2>
    <div class="table-wrap">
      <table id="board">
        <thead>
          <tr><th>Owner</th><th class="right">Projected Points</th><th class="small">Breakdown</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- Regular Season Section -->
  <div class="card">
    <h2>Regular Season</h2>
    <p class="meta">Shows <b>Current</b> (if available), <b>Projected Wins</b>, <b>O/U</b>, and <b>Implied Points</b> = Win-Total EV + Division Title EV.</p>
    <div id="regular-season" class="grid-2"></div>
  </div>

  <!-- Playoffs Section -->
  <div class="card">
    <h2>Playoff Detail</h2>
    <p class="meta">Shows % by round and EV by round. Subtotals include Wild Card Spot (10 pts if not division winner), WC Round, Divisional, Conference, SB Appearance, SB Win.</p>
    <div id="playoffs" class="grid-2"></div>
  </div>
</div>

<script>
/* ---------- utils ---------- */
function clamp01(x){ return Math.max(0, Math.min(1, Number(x)||0)); }
function pct(x){ const v = clamp01(x)*100; return isFinite(v) ? v.toFixed(1)+'%' : '‚Äî'; }
function mlToProb(ml){
  if (ml == null) return 0;
  const n = Number(String(ml).replace(/\s/g,''));
  if (!isFinite(n)) return 0;
  return n < 0 ? (-n)/((-n)+100) : 100/(n+100);
}
function devig(obj){
  const vals = Object.values(obj).map(v=>Number(v)||0).filter(v=>v>0);
  const s = vals.reduce((a,b)=>a+b,0);
  if(!s) return {};
  const out={}; for(const [k,v] of Object.entries(obj)){ const p=Number(v)||0; if(p>0) out[k]=p/s; }
  return out;
}
function mlToMultiplier(ml){ const n=Number(ml); if(!isFinite(n)) return 0; return n>=0 ? (n/100) : (100/Math.abs(n)); }
function winsProjFromNextGameProb(p){ return 17 * (Number(p||0)); }
function winTotalPoints(winsProj, ou, rules){
  const baseOver = Number(rules.win_total?.base_points_if_over ?? 20);
  const baseUnder = Number(rules.win_total?.base_points_if_not_over ?? -20);
  const deltaPts  = Number(rules.win_total?.points_per_win_delta ?? 1);
  const equalIsNotOver = !!rules.win_total?.equal_counts_as_not_over;
  if (!isFinite(ou)) return 0;
  if (winsProj > ou) return baseOver + (winsProj - ou) * deltaPts;
  if (winsProj < ou) return baseUnder - (ou - winsProj) * deltaPts;
  return equalIsNotOver ? baseUnder : 0;
}
async function safeJSON(path){
  try{ const r=await fetch(path,{cache:'no-store'}); if(!r.ok) return null; return await r.json(); }
  catch{ return null; }
}
let TAU = 0.65;
const tauSlider = document.getElementById?.('tauRange');
const tauLabel  = document.getElementById?.('tauVal');

if (tauSlider && tauLabel) {
  tauSlider.addEventListener('input', e => {
    TAU = parseFloat(e.target.value);
    tauLabel.textContent = TAU.toFixed(2);
    main();  // re-run the main render with the new TAU
  });
}
/* ---------- main ---------- */
async function main(){
  const [pred, rules, rosters, odds] = await Promise.all([
    safeJSON('data/predictions.json'),
    safeJSON('data/rules.json'),
    safeJSON('data/rosters.json'),
    safeJSON('data/odds.json')
  ]);
  if (!pred || !rules || !rosters || !odds) {
    document.getElementById('updated').textContent = 'Error loading data';
    return;
  }
  document.getElementById('updated').textContent = 'Updated ' + new Date(pred.generatedAt).toLocaleString();

  /* maps */
  const byTeamNext = Object.create(null);
  for(const t of pred.nflNextGame||[]) byTeamNext[(t.team||'').toUpperCase()] = t;

  // futures (ESPN) + preseason div fallback
  const futures = Object.create(null); // TEAM -> {div, reach_sb, sb, make_playoffs}
  for (const [team, obj] of Object.entries(pred.nflFutures || {})) {
    const T = (team||'').toUpperCase();
    futures[T] = futures[T] || {};
    for (const [k,v] of Object.entries(obj||{})) futures[T][k] = Math.max(futures[T][k]||0, Number(v)||0);
  }
  const divGroups = {};
  for (const t of odds.teams||[]){
    const divKey = `${t.conference} ${t.division}`.toUpperCase();
    divGroups[divKey] = divGroups[divKey] || {};
    divGroups[divKey][(t.team||'').toUpperCase()] = mlToProb(t.div_ml);
  }
  for (const grp of Object.values(divGroups)){
    const norm = devig(grp);
    for (const [team, p] of Object.entries(norm)){
      futures[team] = futures[team] || {};
      if (futures[team].div == null) futures[team].div = p;
    }
  }

  const ouByTeam = Object.create(null);
  const divMlByTeam = Object.create(null);
  for(const t of odds.teams||[]){ const T=(t.team||'').toUpperCase(); ouByTeam[T]=t.ou_wins; divMlByTeam[T]=t.div_ml; }

  /* points config */
  const PTS_DIV_WIN_BASE = Number(rules.division_winner?.base_points ?? 20);
  const PTS_WC = Number(rules.wild_card_spot_points ?? 10);
  const PTS_WC_ROUND = Number(rules.playoff_points?.wc_round ?? 15);
  const PTS_DIV_ROUND = Number(rules.playoff_points?.divisional_round ?? 30);
  const PTS_CONF_CHAMP = Number(rules.playoff_points?.conference_champ ?? 50);
  const PTS_SB_APPEAR = Number(rules.playoff_points?.super_bowl_appearance ?? 75);
  const PTS_SB_WIN = Number(rules.playoff_points?.super_bowl_win ?? 100);

  /* compute per team, bucket by owner */
  const owners = {}; // owner -> { regRows:[], poRows:[], regSubtotal, poSubtotal, total }
  const leaderboard = [];

  for (const player of rosters.players||[]) {
    let totalOwner = 0;
    let regSubtotal = 0;
    let poSubtotal  = 0;

    const regRows = [];
    const poRows  = [];

    for (const pick of player.teams||[]) {
      const name = (pick.name||'').toUpperCase();

      // wins projection
      const nextProb = byTeamNext[name]?.impliedNextGameWinProb ?? 0.5;
      const projWins = winsProjFromNextGameProb(nextProb);

      // O/U and win-total points
      const ou = Number(ouByTeam[name] ?? NaN);
      const wtPts = winTotalPoints(projWins, ou, rules);

      // futures probabilities  (REPLACE EVERYTHING DOWN TO JUST BEFORE // Totals)
const f = futures[name] || {};

// Division EV: preseason ML multiplier √ó current P(div)
const mult      = mlToMultiplier(divMlByTeam[name]);
const pDivTitle = clamp01(f.div ?? 0);
const divEV     = (PTS_DIV_WIN_BASE * mult) * pDivTitle;

// ----- Structure-aware playoff model (smooth + bracket-consistent) -----

// Anchors from market if present
let pSB_win  = clamp01(f.sb ?? 0);       // P(win SB)
let pSB_appM = clamp01(f.reach_sb ?? 0); // P(reach SB), may be missing

// Playoffs top endpoint (fallback if market doesn't provide)
// Use 3√ó reach-SB as a fallback so league totals hit ~14 playoffs (8 div champs + 6 WCs)
let pPO = clamp01( f.make_playoffs ?? (pDivTitle + 3 * pSB_appM) );
if (pPO < pSB_appM) pPO = pSB_appM;

// Wild-card spot (not division)
let pWCspot = clamp01(Math.max(pPO - pDivTitle, 0));

// --- bracket parameters ---
const BYE_RATE = 0.25; // 2 of 8 division winners get a bye
// Map TAU (0.3‚Äì0.8 slider) to a reasonable advancement rate (about 0.35‚Äì0.55)
const tauVal = (typeof TAU === 'number') ? TAU : 0.60;
// Anchor around 0.50 (about half the field advances each round), with a subtle TAU tilt
const ADV = clamp01(0.50 + 0.10 * (tauVal - 0.50)); // TAU 0.35‚Üí~0.485, TAU 0.65‚Üí~0.515
      
// Wild Card round = wildcards + non-bye division winners
let pWCRound = clamp01( pWCspot + (1 - BYE_RATE) * pDivTitle );

// Divisional round = winners from WC + bye teams
let pDivRound = clamp01( ADV * pWCRound + BYE_RATE * pDivTitle );

// Conference = winners from Divisional
let pConf = clamp01( ADV * pDivRound );

// Super Bowl appearance: market if available; else from Conf
let pSBApp = pSB_appM || clamp01( ADV * pConf );

// Ensure monotone: PO ‚â• WC ‚â• Div ‚â• Conf ‚â• SBApp ‚â• SBwin
pSBApp   = Math.max(pSBApp, pSB_win);
pConf    = Math.max(pConf, pSBApp);
pDivRound= Math.max(pDivRound, pConf);
pWCRound = Math.max(pWCRound, pDivRound);
pWCRound = Math.min(pWCRound, pPO); // can‚Äôt exceed playoffs

// EVs
const wcSpotEV  = PTS_WC        * pWCspot;
const evWCRound = PTS_WC_ROUND  * pWCRound;
const evDivRound= PTS_DIV_ROUND * pDivRound;
const evConf    = PTS_CONF_CHAMP* pConf;
const evSBApp   = PTS_SB_APPEAR * pSBApp;
const evSBWin   = PTS_SB_WIN    * pSB_win;
      
      // Totals
      const regPoints = wtPts + divEV; // regular-season subtotal component
      const poPoints  = wcSpotEV + evWCRound + evDivRound + evConf + evSBApp + evSBWin; // playoffs subtotal
      const teamTotal = regPoints + poPoints;

      regSubtotal += regPoints;
      poSubtotal  += poPoints;
      totalOwner  += teamTotal;

      // Tables
      const record = '‚Äî'; // placeholder until we wire standings (wins-losses)
      regRows.push({
        team: name,
        record,
        projWins: projWins,
        ou: isFinite(ou)?ou:'‚Äî',
        regPoints,
        wtPts, divEV
      });

poRows.push({
  team: name,
  // probabilities
  pWCspot,
  pReachWCRound: pWCRound,
  pReachDivRound: pDivRound,
  pReachConfRound: pConf,
  pReachSB: pSBApp,
  pSB: pSB_win,
  // EVs
  wcSpotEV, evWCRound, evDivRound, evConf, evSBApp, evSBWin,
  poPoints,
  // hidden anchors for normalization
  _pPO: pPO,
  _pDivTitle: pDivTitle
});
    }

    // sort per owner
    regRows.sort((a,b)=>b.regPoints - a.regPoints);
    poRows.sort((a,b)=>b.poPoints  - a.poPoints);

    owners[player.owner] = { regRows, poRows, regSubtotal, poSubtotal, total: totalOwner };
    leaderboard.push([player.owner, totalOwner, regSubtotal, poSubtotal]);
  }
// ---- Normalize league totals to exact bracket targets ----
(function normalizeLeagueExact(){
  const T = { wcSpot:6, wcRound:12, divRound:8, conf:4, sbApp:2 }; // exact targets
  const MAX_ITERS = 30, EPS = 1e-4;

  // helper: recompute sums
  function sums(){
    let S = { wcSpot:0,wcRound:0,divRound:0,conf:0,sbApp:0,sbWin:0 };
    for (const [,data] of Object.entries(owners)){
      for (const r of data.poRows){
        S.wcSpot  += r.pWCspot;
        S.wcRound += r.pReachWCRound;
        S.divRound+= r.pReachDivRound;
        S.conf    += r.pReachConfRound;
        S.sbApp   += r.pReachSB;
        S.sbWin   += r.pSB;
      }
    }
    return S;
  }

  // per-team clamping + monotone (uses anchors)
  function clampMonotone(r){
    const pPO  = clamp01(r._pPO ?? 1);
    const pDiv = clamp01(r._pDivTitle ?? 0);
    const pSB  = clamp01(r.pSB ?? 0);

    // order: PO ‚â• WC ‚â• Div ‚â• Conf ‚â• SBApp ‚â• SB
    r.pReachSB        = Math.max(r.pReachSB, pSB);
    r.pReachConfRound = Math.min(r.pReachDivRound, Math.max(r.pReachConfRound, r.pReachSB));
    r.pReachDivRound  = Math.min(r.pReachWCRound,  Math.max(r.pReachDivRound, r.pReachConfRound, pDiv));
    r.pReachWCRound   = Math.min(pPO,              Math.max(r.pReachWCRound,  r.pReachDivRound));
    // WC spot is independent, but keep it ‚àà[0, pPO] and ‚â§ WC round (since WC round implies they play it)
    r.pWCspot         = Math.min(pPO, Math.max(0, r.pWCspot));
    r.pReachWCRound   = Math.max(r.pReachWCRound, r.pWCspot);
  }

  // iterate scaling ‚Üí clamp ‚Üí check
  for (let it=0; it<MAX_ITERS; it++){
    const S = sums();

    // compute exact scale factors (avoid divide-by-zero)
    const k = {
      wcSpot:  S.wcSpot  ? (T.wcSpot  / S.wcSpot)   : 1,
      wcRound: S.wcRound ? (T.wcRound / S.wcRound)  : 1,
      divRound:S.divRound? (T.divRound/ S.divRound) : 1,
      conf:    S.conf    ? (T.conf    / S.conf)     : 1,
      sbApp:   S.sbApp   ? (T.sbApp   / S.sbApp)    : 1
    };

    // apply scaling
    for (const [,data] of Object.entries(owners)){
      for (const r of data.poRows){
        r.pWCspot         = clamp01(r.pWCspot        * k.wcSpot);
        r.pReachWCRound   = clamp01(r.pReachWCRound  * k.wcRound);
        r.pReachDivRound  = clamp01(r.pReachDivRound * k.divRound);
        r.pReachConfRound = clamp01(r.pReachConfRound* k.conf);
        r.pReachSB        = clamp01(r.pReachSB       * k.sbApp);
        // keep SB win market-based (unchanged)
        clampMonotone(r);
      }
    }

    // stop when all within tolerance
    const S2 = sums();
    const done =
      Math.abs(S2.wcSpot  - T.wcSpot)  < EPS &&
      Math.abs(S2.wcRound - T.wcRound) < EPS &&
      Math.abs(S2.divRound- T.divRound)< EPS &&
      Math.abs(S2.conf    - T.conf)    < EPS &&
      Math.abs(S2.sbApp   - T.sbApp)   < EPS;
    if (done) break;
  }

  // recompute EVs, subtotals, and rebuild leaderboard
  for (const [,data] of Object.entries(owners)){
    data.poSubtotal = 0;
    for (const r of data.poRows){
      r.wcSpotEV = PTS_WC         * r.pWCspot;
      r.evWCRound= PTS_WC_ROUND   * r.pReachWCRound;
      r.evDivRound=PTS_DIV_ROUND  * r.pReachDivRound;
      r.evConf   = PTS_CONF_CHAMP * r.pReachConfRound;
      r.evSBApp  = PTS_SB_APPEAR  * r.pReachSB;
      r.evSBWin  = PTS_SB_WIN     * (r.pSB ?? 0);
      r.poPoints = r.wcSpotEV + r.evWCRound + r.evDivRound + r.evConf + r.evSBApp + r.evSBWin;
      data.poSubtotal += r.poPoints;
    }
  }

  // regenerate leaderboard array
  leaderboard.length = 0;
  for (const [owner,data] of Object.entries(owners)){
    const total = (data.regSubtotal||0) + (data.poSubtotal||0);
    data.total = total;
    leaderboard.push([owner, total, data.regSubtotal, data.poSubtotal]);
  }
})();
  // Leaderboard render
  leaderboard.sort((a,b)=>b[1]-a[1]);
  const lb = document.querySelector('#board tbody'); lb.innerHTML='';
  for (const r of leaderboard){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class="owner">${r[0]}</td>
                    <td class="right">${r[1].toFixed(1)}</td>
                    <td class="small">Reg ${r[2].toFixed(1)} ‚Ä¢ PO ${r[3].toFixed(1)}</td>`;
    lb.appendChild(tr);
  }

  // Regular Season render (per-owner cards)
  const regHost = document.getElementById('regular-season');
  regHost.innerHTML = '';
  for (const [owner, data] of Object.entries(owners)){
    const box = document.createElement('details');
    box.open = false;
    box.innerHTML = `
      <summary>${owner}
        <span class="badge">Subtotal: ${data.regSubtotal.toFixed(1)}</span>
      </summary>
      <div class="section-pad">
        <div class="table-wrap">
          <table>
            <thead>
              <tr><th>Team</th><th>Record</th><th class="right">Proj Wins</th><th class="right">O/U</th><th class="right">WT Pts</th><th class="right">Div EV</th><th class="right">Implied Pts</th></tr>
            </thead>
            <tbody></tbody>
            <tfoot>
              <tr><th colspan="6" class="right">Subtotal</th><th class="right subtotal">${data.regSubtotal.toFixed(1)}</th></tr>
            </tfoot>
          </table>
        </div>
      </div>`;
    const tbody = box.querySelector('tbody');
    for (const row of data.regRows){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${row.team}</td>
        <td class="subtle">${row.record}</td>
        <td class="right">${row.projWins.toFixed(1)}</td>
        <td class="right">${row.ou}</td>
        <td class="right">${row.wtPts.toFixed(1)}</td>
        <td class="right">${row.divEV.toFixed(1)}</td>
        <td class="right">${row.regPoints.toFixed(1)}</td>`;
      tbody.appendChild(tr);
    }
    regHost.appendChild(box);
  }

  // Playoffs render (per-owner cards)
  const poHost = document.getElementById('playoffs');
  poHost.innerHTML = '';
  for (const [owner, data] of Object.entries(owners)){
    const box = document.createElement('details');
    box.open = false;
    box.innerHTML = `
      <summary>${owner}
        <span class="badge">Subtotal: ${data.poSubtotal.toFixed(1)}</span>
      </summary>
      <div class="section-pad">
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>Team</th>
                <th class="right small">% WC Spot</th>
                <th class="right small">% WC Rnd</th>
                <th class="right small">% Div Rnd</th>
                <th class="right small">% Conf</th>
                <th class="right small">% SB App</th>
                <th class="right small">% SB Win</th>
                <th class="right">WC Spot EV</th>
                <th class="right">WC Rnd EV</th>
                <th class="right">Div Rnd EV</th>
                <th class="right">Conf EV</th>
                <th class="right">SB App EV</th>
                <th class="right">SB Win EV</th>
                <th class="right">PO Pts</th>
              </tr>
            </thead>
            <tbody></tbody>
            <tfoot>
              <tr><th colspan="13" class="right">Subtotal</th><th class="right subtotal">${data.poSubtotal.toFixed(1)}</th></tr>
            </tfoot>
          </table>
        </div>
      </div>`;
    const tbody = box.querySelector('tbody');
    for (const r of data.poRows){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.team}</td>
        <td class="right small">${pct(r.pWCspot)}</td>
        <td class="right small">${pct(r.pReachWCRound)}</td>
        <td class="right small">${pct(r.pReachDivRound)}</td>
        <td class="right small">${pct(r.pReachConfRound)}</td>
        <td class="right small">${pct(r.pReachSB)}</td>
        <td class="right small">${pct(r.pSB)}</td>
        <td class="right">${r.wcSpotEV.toFixed(1)}</td>
        <td class="right">${r.evWCRound.toFixed(1)}</td>
        <td class="right">${r.evDivRound.toFixed(1)}</td>
        <td class="right">${r.evConf.toFixed(1)}</td>
        <td class="right">${r.evSBApp.toFixed(1)}</td>
        <td class="right">${r.evSBWin.toFixed(1)}</td>
        <td class="right subtotal">${r.poPoints.toFixed(1)}</td>`;
      tbody.appendChild(tr);
    }
    poHost.appendChild(box);
  }
   // --- League totals (expected counts)
const totals = { wcSpot:0, wcRound:0, divRound:0, conf:0, sbApp:0, sbWin:0 };
for (const [,data] of Object.entries(owners)){
  for (const r of data.poRows){
    totals.wcSpot  += r.pWCspot;
    totals.wcRound += r.pReachWCRound;
    totals.divRound+= r.pReachDivRound;
    totals.conf    += r.pReachConfRound;
    totals.sbApp   += r.pReachSB;
    totals.sbWin   += r.pSB;
  }
}
const tgt = { wcSpot:6, wcRound:12, divRound:8, conf:4, sbApp:2, sbWin:1 };
const body = document.getElementById('leagueTotalsBody');
const card = document.getElementById('leagueTotals');
const tauOut = document.getElementById('tauShow');
if (body && card){
  card.style.display = '';
  if (tauOut) tauOut.textContent = (typeof TAU==='number'?TAU:NaN).toFixed(2);
  const rows = [
    ['WC Spot', totals.wcSpot, tgt.wcSpot],
    ['WC Round', totals.wcRound, tgt.wcRound],
    ['Div Round', totals.divRound, tgt.divRound],
    ['Conf', totals.conf, tgt.conf],
    ['SB App', totals.sbApp, tgt.sbApp],
    ['SB Win', totals.sbWin, tgt.sbWin]
  ].map(([label,val,goal]) =>
    `<tr><td>${label}</td><td class="right">${val.toFixed(2)}</td><td class="right small">target ‚âà ${goal}</td></tr>`
  ).join('');
  body.innerHTML = rows;
}
}

main().catch(e=>{
  document.getElementById('updated').textContent = 'Error';
  console.error(e);
 
});
</script>
</body>
</html>
